Вспомнили: Данные внутри барьера живут внутри в виде локальных переменных. 

Скелет программы
```
c = Ab a - nxn матрица
```
Из-за обращений к памяти может быть так, что программа даже при распараллеливании не ускорится. И если правильно организовать работу с памятью, можно в 4 раза ускорить работу программы, ведь мы работаем с NUMA процессорами. 

В си когда вызываем malloc, страницы только резервируются, они ещё не отображены в память. И когда вызываем, происходит отображении именно на ту часть процессора, где он сейчас работает. Поэтому нужно зафиксировать правильный NUMA узел, где и будет расположена память. 

```cpp
class Args
{
	double *a = nullptr;
	double *b = nullptr;
	int tid;
	...
}

main (...) {
	Args *args;
	//выделяем Args, Но НЕ ОБРАЩАЕМСЯ
	...

	дела
	for (k = 0; k , p; k++) {
		args[k].a = a;
		...
	}
	создаём p-1 поток
	for () {
		pthread_create(..., thread func ...);
	}
	args[0].tid = pthread_self();
	thread_func(args + 0);
	// ^--reduce_sum
	for (k = 1; k < p; k++) {
		pthread_join(...);
	}
	// Тут уже работает только один поток
	proverka_na_errors;
	print_otvet;
	print_time; // важно правильно сбалансировать нагрузку поттоков
	delete_memory;
}
```

```cpp
void thread_func(void *ptr)
{
	Args *A = (Args*) ptr;
	double *a = A->a;
	double *b = A->b;
	int p = A->p;
	int k = A->k;
	...
	char *name = A -> name;
/*  pthread_setaffinity() - позволяет привязать потоку процессор
	pthread_t tid, size_t cpusetsize, cpu_size-t *cpu - аргументы*/
	cpu_set_t cpu;
	CPU_ZERO(&cpu); // вместо конструктора, си оч старый
	int n_cpus = get_nproc(); // число процессоров
	// Лучше занимать последние процессоры, они менее нагружены
	int cpu_id = n_cpus - 1 - (k % ncpus);
	pthread_t tid = A -> tid;
	// или pthread_t tid = pthread_self();
	pthread_setaffinity_np(tid, sizeof(cpu), &cpu);
	// Теперь можно и обращаться к памяти, только после того, как определили проц
}
```

1) Обратиться к своей памяти (заполнить 0ми)
2) Назвать её своей
3) Обращаться только к своей

```

m_______________________________0
m_______________________________1
m_______________________________2
m_______________________________0
m_______________________________1
m_______________________________2
<=m_____________________________0

```

Пример: обращаемся к памяти по строчкам
```cpp
//где-то main
main(...) {
	double global_res = 0;
}
```

```cpp
class Args {

}
```

```cpp
int i; int h; // h - высота (число строк в блочной строке)
for (i = k * m; i < n; i += p * m) { //p - число потоков, m - длина строки
	h = (i + m < n ? m : i + m - n);
	//i - номер строки, n - смещение
	memset(a + i * n, 0, h * n * sizeof(double)); // работает с байтами
	// заполняет массив нулями
	memset(b + i, 0, h * sizeof(double));
	memset(c + i, 0, h * sizeof(double));
}

if (name != nullptr) {
	//читаем из файла
	if (k == 0) { // Если это главный поток (но можно и любой другой)
		res = read_array(a, h, name);
		A->res = res; // *(A->global_res) = res
	}
	reduce_sum(p, &res, 1);
	// альтернатива:
	pthread_barrier_wait(&b);
	A[-k].res // Так работает, но делать не стоит
	if (*(A->global_res)) {...}
	// конец альтернативы
	if (res > 0) {
		if (k == 0) {
			printf("Can't read %s\n", name); // Печать может быть точкой синхронизации
		}
	} else {
		init_matrix(a, n, s, k, p);
	}
	bi = сумма столбцов через 1;
	itit(a, n, b, k, p); // внутри неё есть точки синхронизации
	if (k == 0) {
		print_matrix(a, n, n_max); // 3
	}
	reduce_sum(p); //чтобы во время печати какой-то поток не изменил данные в 0м
	// Тут лучше выделять память
	double t = get_cpu_time();
	solve(a, b, c, n, k, p);
	t = get_cpu_time() - t;
	A -> t = t;
	if (k == 0) {
		print_otvet
	}
	reduce_sum(p);
	// Тут лучше освободить локальную память
}
```
### Выделение доп памяти
1) NUMA - в поток
2) false sharing
Если выделить $m^2 * p$ памяти, и распределить эту память по потокам
`|_______0_______|_______1_______|_______2_______|`
То может быть проблема с наложением памяти. Поэтому лучше выделять память локально в потоках

```cpp
void init_matrix(double *a, int n, int m, int s, int k, int p)
{
	// инициализация по своим строкам, то есть по строкам по модулю p
	int i, j;
	for (i = k * m; i < n; i += p * m) {
		int h = (i + m < n ? m : i + m - n);
		for (i2 = i; i2 < i + h, i2++) {
			for (j = 0; j < n; j++) {
				a[i2 * n + j] = f(i2m j, n, s);
			}
		}
	}
	reduce_sum(p);
}

void matrix_mult_vector(double *, double *b, double *c, int n, int m, int k, int p)
{
	int i, i2, j;
	double s;
	for (i = k * m; i < n; i += p * m) {
		int h = (i + m < n ? m : i + m - n);
		for (i2 = i; i2 < i + h, i2++) {
		s = 0;
			for (j = 0; j < n; j++) {
				s += a[i2 * n + j] * b[j];
				//   ^^^-своя память  ^^^-чужая (а может и своя)
			}
			c[i2] = s;
		}
	}
	reduce_sum(p);
}
```

# Практикум
Есть последовательности ${x_i^{(k)}}$. Ответ раньше был суммой результатов. 
Теперь у нас есть вектор функции $F_k = F(x_i^{(k)})$
$g = G({F_k})$
Потом второй раз открываем файлы и пробегаемся по ним
$H = sum(k=1, p, H_k)$
### Пример задачи
Найти количество $x_i^{(k)} < {среднего}{.}{арифмечического.} {x_i^{(k)}}$
Решение:
1) Пробегаемся, вычисляем среднее арифметическое для каждого файла
2) Вычисляем среднее арифметическое у всех
3) Пробегаемся ещё раз, считая количество