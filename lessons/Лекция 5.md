Межпроцессное взаимодействие
- Передача данных
- Ожидание изменения состояния
Взаимодействие бывает 
- Синхронным
- Асинхронным (передаём указатель для вызова в непредсказуемый момент времени)
Разделяемая память - ситуация, когда у двух процессоров есть отображение виртуальной памяти на физическую, и оно взаимооднозначно. При таком образе взаимодействия за сохранность данных отвечает прогер. Для избежания перезаписи важных данных используется семафор. 
``` c
get(s)
if (s != 0) {
	s = 0;
	// ...
	s = 1;
}
else wait(s);
```
Ячейки симофора лежат в ядре операционки. 
# Сигналы
асинхронная. Нужно будет зарегистрировать обработчик, который будет их отслеживать. 
wait - синхронное ожидание
или зарегистрировать обработчик
Общее определение:
Ресурс - что-то нужное для работы процессу/потоку
Бывают:
- Аппаратные (процессор, память)
- Программные (канал, файл)
Разделяют на активные:
- Активные - изменяют информацию, с которой работают.
- Пассивнае - хранят данные
Также ресурсы бывают:
- Локальные - внутри потока
- Глобальные - видны всем процессам/потокам
- Разделяемые - одновременно используемые несколькими процессами/потоками
Ещё бывают:
- Постоянными - "взять", "открыть", а потом освободить
- Временными - "создать", потом "удалить"
Ещё
- Не криичными - могут использоваться без ущерба
- Критичные - в каждый момент один процесс использует ресурс
# Типы взаимодействия процессов/потоков
Каждый поток работает со своим ресурсом. Есть сотрудничающие, например, один пишет в файл, другой из него же читает. В этом случае нужно как-то синхронизировать. Ещё есть конкурирующие, которые борятся за использование ресурса.
Например, есть 2 потока, которые выполняют x++
```
// P1
x++;
1 x -> r0
2 r0 + 1 -> r0
3 r0 -> x

// P2
x++;
4 x -> r0
5 r0 + 1 -> r0
6 r0 -> x

Причем действия 1, 2, 3 и 4, 5, 6 могут работать в случайном (но последовательном для каждого) порядке

Результат может колебаться между 2 и 3, если изначально х был 1
```
Критическая секция - участок программы, участок, где запрещено переключение программ. Например, так живёт операционная система.

Взаимное исключение - семафор. 
Чтобы занять ресурс, нужно проверить занятость, а в конце освободить. Нужно сделать очередь ожидающих, отсортированная по приоритетам, или FIFO.
# Проблемы
Ситуация: 2 процесса и 1 ресурс. 
Первый процесс говорит get, работает, put. Тоже самое для 2 процесса. Тут всё легко и понятно.

Ситуация: 2 процесса и 2 ресурса, оба используются 2 ресурсами.
Первый получает 1 ресурс, второый получает ресурс 2. В процессе работы первый процесс хочет получить 2 ресурс, а 2й ресурс хочет первый. И теперь они оба впадают в режим ожидания. 
Deadlock - программа зависла. ТУПИК
Starvisio - застой, если один поток постоянно держит и не отпускает ресурсы.
Lockout - низкоприоритетный ресурс не даёр работать высокоприоритетному, т.к. он - владелец ресурса.
# Состояния процессов
1. Не существует
2. Не обслуживается
3. Готов
4. Выполняется
41. Ожидает ресурс
42. Ожидает время
43. Ожидает событие
После ожидания переходит в состояние готов
Не существует >> Не обслуживается >> Готов >> Выполняется
Выполняется >> Ожидает ресурс >> Готов
Выполняется >> Ожидает время >> Готов
Выполняется >> Ожидает событие >> Готов
# Процессы
IPC
Interprocess communication
``` c
<sys/ipc.h> // Стандартная библиотека
<sys/shm.h> // Shared memory - разделяемая память
shmget(identificator, size); // Дай мне память на размер
// Идентификатор - число
// Может быть IPC_PRIVATE - сделай какое-то
// Для 1-го - это создать
// Для 2, 3... - это дать имеющуюся
// Если указать что-то похожее на имя файла - оно будет использоваться
// в качестве идентификатора. Например "имя_файла" /proc/shm/... - тут хранится
// и после перезагрузки.
shmat(id, adress); //shard memory attach - Куда-то в адресное пространство 
// прикрепляет кусок. Что-то вроде fopen. 
```

```c
class list_node: public node
{
private:
	size_t offset = 0;
	list_node *next = nullptr;
public:
	//...
}
// Вывод - нельзя хранить ссылочные типы данных.
```

```c
shmdt(...); // shared memory detach (отсоединение)
shmctl(...); // удалить память - отложенное удаление. Оно не происходит, 
// пока хоть один процесс имеет отображение на эту память
// владелец разделяемой памяти - ядро системы
// чтобы посмотреть на неё - ipsls в shell
``` 
Какие последствия:
1. Вся память нарезается из 1 куска операционной системы => Размер не превышает 64Мб. Это для небольших объектов, обеспецивающих общение процессов
2. При использовании памяти происходит переключение отображеня виртуальной памяти на физическую

# Семафоры
```c
<sys/sem.h>
semget(); // вектор из n штук. Взять n семафоров - счётный
// бывают булевские или счётные (0, 1, ..., n-1)
semop // операция с массивом семафоров
// get    -1
// put    +1
// можно попробовать взять
// Можно удалить семафор
semctl // все ожидающие семафоры активизируются
// Можно запустить приоритетный
// 
```
# Событие
Есть абстрактный event, нереализованный в (???)
`signal(E)` - что-то делает, непонятно что
`brodcust(E)` - активировать всех, кто в состоянии `wait`
`test(E)` - проверить, есть ли событие
`reset(E)` - сброс события
События реализованные в Unix системах
- Зарегистрировать обработчик с помощью функции `signal(???, number_from_1_to_64)`
- Отправить сигнал `kill(pid_number_of_signal)`. Если нет обработчика, то процесс будет убит
Примеры сигналов
- 11 - `Segmentation fault`
- 8 - `Floating point Exception`
- 9 - `Sigkill` - на него обработчик поставить нельзя
- 15 - `sigterm`
- `sigpipe` - разорванное socket соединение
- `kill -9 -1` - убивание графической оболочки
```c
<sys/msg.h> // Очередь сообщений
<pipe.h> // Для нотификации
// shell: make | less
```