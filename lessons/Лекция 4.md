Рассмотрели систему с неоднородным доступом к памяти. Выглядят как 2 фищических сокета с ядрами внутри. Производительность памяти умножается на число контроллеров памяти. И Умножается на ширину. Современные процессоры обладают больше 4000 ножек. Теперь в каждом лежит 8 NUMA узлов по 8 ядер каждый. Поэтому использовать NUMA архитектуру надо. Все процессоры с более 1 сокетом - NUMA архитектура. Нужно учитывать соединения внутри и между процессорами, ведь они могут замедлять программу в 2-4 раза. 
Синхронизация КЭШа. Трафик КЭШ-когерентности занимает 70% чего-то. За счёт высокой скорости сети можно виртуально обеспечить. 

Для систем с распределённой памятью (общение сообщениями), невозможно оценить сложнность алгоритма. 
Чтобы максимизировать работу со своими данными (те, к которым максимально быстрый доступ), нужно решить 2 задачи:
- Как выделить свою память?
- Как не потерять свою память?
``` cpp
double * p = (double*) malloc(n * sizeof(double));
double * p = new double[n];
```
В этот момент происходит не выделение новой памяти, а резервация виртуальной. 
```
виртуальная - по 4Кб. 
|___|___|___|___|___|___|___|___|___|___|___|___|___|___|___|___|___|
Не точное отождествление!

|___|___|___|___|___|___|___|___|___|___|___|___|___|___|___|___|___|
физическая
```
После выделения мы резервируем виртуальную, но не отображаем в физическую. 
Если выделить 1Тб, то всё будет хорошо до тех пор, пока не обратимся и не построим отображение виртуальной и физической. 
1 проблема решена, так как отображение строится в тот момент, когда мы отображаем виртуальную память, тогда мы и будем обращаться к своей памяти. 

2 проблема
Планирование ресурсов осуществляется с помощью квантов времени - интервалов планирования. 
В Линуксе раньше 1/100 секунды, сейчас 1/1000 секунды. Т.е. переключение между задачами происходит 1000 раз в секунду. 
```
1 задача          2 задача          1 задача
<---------><------------------><------...
   __   __   __   __   __   __   __   __
__| |__| |__| |__| |__| |__| |__| |__| |__
```
Нужно восстанавливать на то же ядро, что мы и были до этого. Сейчас линукс осуществляет переход на случайное ядро. Как запретить переключать ядра? Мы можем указать список процессоров, на которых будем работать. Называется affinity. Но нужно занимать последние ядра. Побочка - может даже сохраниться L1 кэш. Благодаря этому программа будет работать минимум времени. 
Схема:
- new
- привязать ядро
- обратиться
Первые 2 пункта можно менять местами. 

Сейчас даже в биосе можно выбирать, сколько будет NUMA узлов, например:
- 16 (для программ, которые умеют работать с NUMA)
- 8
- 4
- 2
- 1 (для банковских приложений)
Стандартная библиотека языка С
``` c
#include <sched.h>
#include <sys/types.h>
#include <unistd.h>

// Описание набора (логических)процессоров. Договоримся о 
// терминологии. То, что исполняет - ядро.
// Есть физический процессор - битовая реализация 
// множества на базе массивов. 1 - если присутствует в массиве,
// 0 - если нет. cpu_set_t - тип, описывающий набор процессоров. 
// Это указатель на массив, подходящей длины для Вашей системы.

cpu_set_t cpu;
CPU_ZERO(&cpu); // - обнулить - инициализация - делается пустым
CPU_SET(k, &cpu);
// идентификатор процессора - индикатор, 
// который система присвоила процессору
// 1, ..., 2^16 или 2^32
int sched_set_affinity(pid_t pid, // идентификатор процессора
					  seze_t cpusetsize,
					  const cpu_set_t * mask // запускать только на выбранных
											 // процессорах
					  );
pid getpid(void); // номер процессора, на котором сейчас работаем

int get_nproc(); // Возвращает количество логических процессоров системы

int main(int argc, char *argv[]){
	...
	double *a = new[n*n];
	if (a == nullptr) {
		...
	}
	int proc = get_nprocs();
	cpu_set_t cpu;
	CPU_ZERO (&cpu);
	CPU_SET(nproc-1,  &cpu); // выбираем нужный проц, последний
	sched_set_affinity(getpid(), sizeof(cpu));
}


```
``` shell
ps x
ps xm # показать количество потоков
taskset --help
lscpu
taskset -p 1565
taskset -pc 1,3 1565
# a
taskset -pc 0,3 1565
#f
```
Процесс - программа во время исполнения
- Есть область опер памяти, с которой он работает,
- отображение виртуальной памяти на физическую,
- потоки исполнения. По умолчанию 1 штука, в котором исполняется main
Поток исполнения - динамическая сущность
- Имеет свой стек
- Имеет своё состояние
- Разделяет с процессором область памяти
- Разделяет с процессором отображение виртуальной памяти на физическую
Состояние
- Бывает "остановлен", "детерминирован", "готов", "выполняется"
- Выполняется - Не превышает число логических процессоров
- В состоянии готов >1 => программа многопоточна
Стек - временная область памяти
1) Сохраняет адрес возврата
2) Созраняет локальные переменные и регистры, доступные для изменения
3) Сохраняет контекст потока
контекст = набор всех регисров, доступных для изменения
``` c
{
	y = f(x); // вызов функции
	// создаётся память в этом стеке для аргументов
	// копируются аргументы
	// сохраняется адрес возврата
	// переход по адресу f - синтаксически адрес начала функции
	// сохраняется память под локальные переменные
	// сохранение регистров, которые используются, но должны быть сохранены
	// выполняется функция
	// результат функции в регистре int/fp
	// восстановление регистров
	// возврат по адресу возврата
	// удаляются ret, аргументы
}
```

Планирование происходит за счёт приоритетов
Light Waight Process (LWP) - Потоки получают поровну
Threads

Приоритеты:
- статические. Используются в системах реального времени, например, для обработки экстренных ситуаций. 
- динамические. Процесс переходящий из состояния ожижание в состояние готово, получает максимальный приоритет. После отработки 1го кванта, его приоритет понижается. 
Выдаётся по умолчанию новое ядро из списка affinity. 
threads per core - 1 или 2(расщепление конвейера). Логическое ядро, физическое ядро, физический процессор. 
Расщепление всех конвейеров в ядра в intel называется hyperthreading
cores per socket - 4
sockets - 1

Если в состоянии готов несколько задач с одинаковым приоритетов, то обычная циклическая обработка всех потоков. 

# Семинарская часть
1) $n^2$ $a_{ij} <=> a[i * n + j]$ по строкам  и $a[j * n + i]$ по столбцам
2) $a[i][j]$ плохой способ, так как лишние обращения памяти