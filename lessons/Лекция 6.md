Изначальный стандарт UNIX
Названия у всех разные

IBM -> AIX
Silicon -> Oracle -> IRIX
San -> Oracle -> Solaris
HP -> HPUX
Linux

POSIX standart - Portable operation system IX

Создание нового прцесссора сильно влияет на интерфейс. 

Процессы в UNIX системах

В виртуалной памяти выделена память для стека (контекст). 
В UNIX системах блок этой памяти полностью описывает состояние процессора. Кто-то даже записывает логи на диск. У этой виртуальной памяти есть отображение на физическую и это самая дорогая операция. 

# fork()
При создании нового процесса пошли путём создания клонов. Клон - процесс, в начальный момент времени полностью повторяющий виртуальную память родителя. Просто возникает новый pid процесса, во всём остальном полностью идентичны. 
```
pid_t fork(id);
```
В родителе возвращается pid потомка, в потомке 0. В остальном одинаковые процессы. Копия таблицы. У них вся память общая. Как только родитель или потомок пишет в ячейку памяти, то у него меняется отображение только для ЭТОЙ ячейки, у второго остаётся прежней. Но есть и неизменяемые куски памяти, например, с кодом программы или используемой библиотеки.

Если один создал разделяемую память до форка, то все будут ей пользоваться

Чтобы заместить процесс на другой, есть функция 
```
int exect(const char *name, const char *arg0, const char *arg1, ...);
// или 
int execv(const char *name, char * const arg[]);
```
Он сохраняет отображение виртуальной памяти на физическую, но процесс ПОЛНОСТЬЮ замещается, то есть всё, что есть после exec, то оно не выполнится. Это харакири. Камикадзе в мире параллельного программирования.

```cpp
pid_t pid;
pid = fork();
if (pid == 0) {
	/*потомок*/
	exect("/bin/ls", "/bin/ls", "-l", 0);
	printf("Error\n");
	abort();
} else {
	/*родитель*/
}
```

У потомка выполняется процесс `$ ls -l &`, но как сделать `$ ls-l`? 
```cpp
if waitpid(pid, &status, 0);
```

список сигналов
```bash
$ kill -l
```
Процесс с номером 1 - init, единственный сирота без родителя
```bash
pstree //посмотреть все процессы
pstree -p //с номерами процессов
```
Динамические библиотеки
Статические библиотеки (статичное связывание, напр `include`)

В Windows НЕТ функции fork. Потому что оперативная память не полностью задаёт начальное состояние.

fork + exec = spawn

После форка процессы полностью независимы, но должно быть что-то общее, например, разделяемая память. Если рассмотреть 2 потока, то у них вообще всё общее, но разный стек, состояние, и не стоит вопрос с передачей данных. 
# POSIX THREAD
Изобрела San microsystems. Был заголовочный файл 
```cpp
#include <thread.h>
```
Но сейчас современный threads - posix threads
```cpp
#include <pthreads.h>
```
И нужно при компиляции указать это (ТОЛЬКО В КОНЦЕ)
```bash
g++ file.cpp -l pthread
```
Также вместо этого в опции компилятора можно указать на любом месте опцию, которая позволить работать с потоками
```bash
g++ -pthread file.cpp
```
 
ВСЕ функции в <pthread.h> начинаются с pthread_
Имеютследующий прототип:
```cpp
int pthread_что-то(args);
// Возвращает 0 в случае успеха
```

Создание потока
```cpp
int pthread_create(pthread_t *tid, )
// возвращает идентификатор созданного потока

const pthread_attr_t *attr, 
/*
	1) LNP / pthread
	2) joinable state - pthread_join
	допустим nullptr - используется в linux
*/

void  *(*start_routine) (void *)
```
1. Начинаем с идентификатора
2. Если нашли пару и интерпретировать внутри
3. Если справа есть открывающаяся скобка, то это функция
	- f
	- f
4. Если справа стоит квадратная скобка, то это массив
	- Найти закрывающуюся кв скобку
	- Внутри них длина
5. Если слева звёздочка, то это указатель
	- Остаток - то, но что указывает
```cpp
int a;
int *b;
int *c(); // иниц функции
int (*d)(); // указатель на функцию
int *e[5]; // массив указателей 
int (*f)[5]; // указетель на массив из 5 элементов
int *g[5](); // массив функций, этого быть не может
int (*f[5])(); // массив указателей на функции
```

```cpp
startroutine(arg);
```

```cpp
int pthread_join(pthread_t tid, void **res);
// res - возв значение
```

```cpp
#include <pthtread.h>
#include <stdio.h>

void *thread_func(void *arg) {
	int k = *((int *)arg); // номер потока
	printf("Hello frod thread %d\n", k);
	return 0;
}
// a.out 5 - 5 потоков
int main(int arg, char *argv[])
{
	int *arg = nullptr;
	pthread_t *tid= nullptr;
	int p, k;
	if (argc != 2 || sscanf(argv[1], "%d", &p) != 1) {
		printf("Usage: %s num\n", argv[0]);
		return -1;
	}
	args = new int[p];
	tid = new pthread_t[p];
	if (args == nullptr || tid == nullptr) {
		printf("Cannot allocate memory\n");
		if (args != nullptr) delete[] args;
		if (tid != nullptr) delete[] tid;
	}
	for (k = 0; k < p; k++) args[k] = k;
	for (k = 1; k < p; k++) {
		if (pthread_create(tid + k, 0, thread_func, args + k)) {
			printf("Can not creat thread: %d\n", k);
			abort();
		}
	}
	thread_func(args + 0);
	for (k = 1; k < p; k++) {
		pthread_join(tid[k], 0);
	}
	delete[] args;
	delete[] tid;
	return 0;
}
```