Для распараллеливания мы распилили матрицу на полосы, потом умножали строку на столбец. На основе этой программы можно реализовать распараллеленное умножение двух матриц. Умножение вектора на вектор  $2n - 1$, умноженое матрицы на вектор $2n^2 + O(n)$, умножение матрицы на матрицу  $2n^3 + O(n^2)$, однако из-за возникновения конфликта по чтению выходит так, что ускорения нет.
A x B = C
Рассматриваем разбиение матриц А и В по строкам. Перестроить формат хранения матрицы В на разбиение по столбцам - нереальная задача, по времени и сложности гораздо сложнее текущей. Будем искать решение текущей проблемы. 
Попробуем разбить мысленно ещё и на столбцы. Для каждого диагонально элемента матриц А и В мы их можем без проблем перемножить благодаря тому, что они хранятся в соответственных местах.
Сделаем точку синхронизации. 
Сейчас наша задача сделать так, чтобы параллельные процессы не обращались к одной и той  же памяти
![[telegram-cloud-photo-size-2-5294353899303592839-y.jpg]]
![[telegram-cloud-photo-size-2-5294353899303592841-y.jpg]]

## Вычитание в методе Гаусса
Копируем блок, и затем его вычитаем для каждой следующей строки, так как он хранится в кэше нашей памяти

## В следующий раз - отчёт по параллельной реализации!
./a.out n m p r s file.txt
n - размер матрицы
m - размер блока
p - количество потоков
r - количество печатаемых
s - номер формулы

Что нужно отразить в отчёте?
### 1. "Разделение данных": свои - чужие
Для Гаусса/Жордана - разделение памяти либо по строчкам, либо по столбцам
Разницы нет, ведь в одном случае мы умножаем на элемент столбца, а в другом вычитаем строку
Далее смотрим на выбор главного элемента. Для выбора во всей матрице - без разницы. 
Если выбор по строке, то мы должны обратить все элементы строки, аналогично для столбцов. Действий выйдет порядка $sum (c * m^3 * n/m)$ ~ $c * m * n^2$
Если выбор главного по строке/столбцу - почти без разницы. 
1) Если выбор по столбцу, и разбиение по строкам, то проблема в перестановке строк (оч плохо для MPI)
2) Если выбор по строке и разбиение по строкам, то проблема в обращении матриц. Все потоки разбирают по блоку в строке, и обращает его. И перестановка столбцов параллельна. 
Аналогично для разбиения хранения по столбцам. 
3) Если выбор по столбцу и разбиение по столбцу, то
	- всеми потоками находим обратный, обращаясь к чужой памяти
	- но перестановка параллельна
4) Если выбор по строке, а хранение по столбцам, то
	- Параллельно находим обратный
	- Перестановка столбцов не параллельна
	- Тут возникает дополнительный обмен

После разделения данных каждый из потоков нашёл обратные в своей части. Как найти победителя?
```cpp
reduce_sum // делали
reduce_min // ищем минимум

for (...) {
	r[i] = (r[i] < a[i] ? r[i] : a[i])
}

reduce_max
	a[i] в потоке i
	||A^-1||, если есть обр
	0, иначе

struct double_int
{
	double norm;
	int i;
}

void reduce_max(int p, double_int *a, int l)
Не удобно!!
_____________________________________________
2 способ
double * norm;
int *index;
	norm[k] = норма обратной
	index[k] = индекс обратной
```
Этот вектор один на всех, удобно. 

### 2. Формула на поток
для $i = k + p * j * m$, k - номер потока, j - перечисляет цикл из p потоков
нашли обратную $C = A_{11}^{-1}$
Для блочных строк $A_{1i} = C * A_{1i}$
Точка синхронизации тут. Их количество вообще должно быть линейно. 
$A_{ij} = A_{ij} - A_{i1}*A_{1j}$, j = 2..., i=2...
Если коротко, нужно взять старый отчёт и чётко определить принадлежность своему потоку. 
### 3.  Формула сложности
$c_1n^3 + c_2n^2m + c_3nm^2 + c_4m^3 + O(n^2 + nm + m^2)$ - Для последовательной реализации
$S(n, m, p) = 1/p * S(n, m)$
$S(n, m, p) = 1/p(c_1n^3 + c_2n^2m + c_3nm^2 + c_4m^3 + O(n^2 + nm + m^2))$
-  На p должны делиться все слагаемые последовательной реализации
- p = 1 => S(n, m, p) = S(n, m)
- Рассмотреть случаи n == m, m == 1
Это для обычных методов
Для методов вращений-отражений возникает $log_2(p)$

### 4. Оценка числа точек синхронизации
Она должны быть $C * n/m$
2...4 с обратным ходом
4...6 для нахождения $A^{-1}$
Если количество точек синхронизации $(n/m)^2$ можно даже не начинать писать программу.


## Примечания
Для LU и Холецкого разбиение памяти происходит ёлочкой или обратной
```
_| | | | |
___| | | |
_____| | |
_______| |
_________|
```
Для методов вращений и отражений что-то обсуждали, но я ниче не понял. Нужно придумать, как грамотно распараллелить. 

# Продолжении лекции
Самые большие изменение библиотеки языка C
1) `_r` - позволяют параллелить
2) malloc/free - привязка происходит при первом обращении
3) malloc/free - стали параллельными
Если идёт вызов с разных NUMA узлов, выделение будет параллельным
Функция очень дорогая

# Практикум
{x_1,...,x_10} - в файле а
{x_11,...,x_20} - в файле b
{x_21,...,x_30} - в файле b

`./a.out s` - В одном файле, вычисляется в 1 потоке
`./a.out a b c` - Разрезали на 3 файла

Найти длину максимального участка возрастания
Пример: ` 1 | 2 |   | 3 ` - 4 файла, самый длинный участок из 3х элементов. 
```cpp
class result
{
public:
	double first = 0;
	double last = 0;
	double count = 0;
	double len_first = 0;
	double len_last = 0;
	double len_max = 0;
	...
	ошибки чтения/открытия
}

int process_res(result *r, int p) {
	// обработка ошибок, как в задании 2
	int k, len_max = r[0].len_max, len_curr = r[0].len_last;
	for (k = 1; k < p; k++) {
		if (r[k].first >= r[k-1].last) {
			// продолжается
			len_curr += r[k].len_first;
			if (len_max < len_curr) len_max = len_curr;
			if (r[k].count > r[k].len_first) len_curr = len_last;
		} else {
			len_curr = r[k].len_max;
			if (len_max < len_curr) len_max = len_curr;
			
		}
	}
}
```

